/**
 * Fetches, parses, and displays data for the portfolio.html page.
 * This script handles the portfolio results, historical values, and summary details.
 */

// --- CONFIGURATION: Paths to the data files generated by Portfolio.py ---
const SUMMARY_CSV_PATH = 'data/portfolio_results_db.csv';
const HISTORY_CSV_PATH = 'data/portfolio_value_db.csv';
const LATEST_RUN_SUMMARY_JSON_PATH = 'data/latest_run_summary.json';

// --- MAIN EXECUTION ---
document.addEventListener('DOMContentLoaded', main);

async function main() {
    try {
        const [allSummaryData, allPortfolioHistoryData, latestRunJson] = await Promise.all([
            fetchAndParseCsv(SUMMARY_CSV_PATH + '?t=' + new Date().getTime()),
            fetchAndParseCsv(HISTORY_CSV_PATH + '?t=' + new Date().getTime()),
            fetch(LATEST_RUN_SUMMARY_JSON_PATH + '?t=' + new Date().getTime()).then(res => {
                if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
                return res.json();
            })
        ]);

        const twelveMonthsAgo = new Date();
        twelveMonthsAgo.setFullYear(twelveMonthsAgo.getFullYear() - 1);
        twelveMonthsAgo.setHours(0, 0, 0, 0);

        // Sort the chart data in ascending order by date
        const filteredSummaryData = allSummaryData.filter(row => {
            const timestamp = new Date(row.timestamp);
            return timestamp && timestamp >= twelveMonthsAgo;
        }).sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp)); // Sort ascending (oldest first)

        // --- Render all components on the page ---
        displayLastPortfolioDetails(latestRunJson.best_portfolio_details, latestRunJson.last_updated_run_id);
        createLastPortfolioPieChart(latestRunJson.best_portfolio_details);
        renderOptimalPortfoliosStackedBarChart(filteredSummaryData);
        // For the main table, sort descending to show newest first
        populateResultsTable(filteredSummaryData.slice().sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp)));

    } catch (error) {
        console.error('Error in main function:', error);
        const errorMessage = `Error loading data: ${error.message}. Check console.`;
        document.getElementById('resultsTable').getElementsByTagName('tbody')[0].innerHTML = `<tr><td colspan="10" class="status-error-row">${errorMessage}</td></tr>`;
        document.getElementById('bestPortfolioTable').getElementsByTagName('tbody')[0].innerHTML = `<tr><td colspan="2" class="status-error-row">Error loading last portfolio details.</td></tr>`;
        document.getElementById('optimalPortfoliosStackedBarChart').textContent = 'Error loading chart data.';
    }
}

// --- DOM UPDATE FUNCTIONS ---

function populateResultsTable(summaryData) {
    const tableBody = document.getElementById('resultsTable').getElementsByTagName('tbody')[0];
    tableBody.innerHTML = '';

    if (!summaryData || summaryData.length === 0) {
        tableBody.innerHTML = `<tr><td colspan="10" style="text-align:center;">No portfolio data found for the last 12 months.</td></tr>`;
        return;
    }

    const rowsHtml = summaryData.map(row => `
        <tr>
            <td>${row.run_id || 'N/A'}</td>
            <td>${formatDate(row.timestamp)}</td>
            <td>${row.engine_version || 'N/A'}</td>
            <td>${row.min_stocks || 'N/A'}</td>
            <td>${row.max_stocks || 'N/A'}</td>
            <td>${row.stocks || 'N/A'}</td>
            <td>${row.weights || 'N/A'}</td>
            <td>${formatNumber(row.sharpe_ratio, 4)}</td>
            <td>${formatNumber(row.expected_return_annual_pct, 2)}%</td>
            <td>${formatNumber(row.expected_volatility_annual_pct, 2)}%</td>
        </tr>
    `).join('');
    tableBody.innerHTML = rowsHtml;
}

function displayLastPortfolioDetails(details, runId) {
    const tableBody = document.getElementById('bestPortfolioTable').getElementsByTagName('tbody')[0];
    tableBody.innerHTML = '';

    if (!details) {
        tableBody.innerHTML = `<tr><td colspan="2" style="text-align:center;">No portfolio found in the last run (ID: ${runId || 'N/A'}).</td></tr>`;
        return;
    }

    // Removed Final Value, ROI, and Initial Investment
    const detailsMap = {
        "Run ID": runId || 'N/A',
        "Sharpe Ratio": formatNumber(details.sharpe_ratio, 4),
        "Optimal Stocks": details.stocks ? details.stocks.join(', ') : 'N/A',
        "Optimal Weights": details.weights ? details.weights.map(w => formatNumber(w, 4)).join(', ') : 'N/A',
        "Expected Annual Return": `${formatNumber(details.expected_return_annual_pct, 2)}%`,
        "Expected Annual Volatility": `${formatNumber(details.expected_volatility_annual_pct, 2)}%`
    };

    const rowsHtml = Object.entries(detailsMap).map(([metric, value]) => `
        <tr>
            <td><strong>${metric}</strong></td>
            <td>${value}</td>
        </tr>
    `).join('');
    tableBody.innerHTML = rowsHtml;
}


// --- CHARTING HELPERS & FUNCTIONS ---

/**
 * A shared configuration object for Plotly charts to ensure a consistent look and feel.
 */
const PLOTLY_COMMON_LAYOUT = {
    paper_bgcolor: 'rgba(0,0,0,0)',
    plot_bgcolor: 'rgba(0,0,0,0)',
    height: 450,
    showlegend: false // Most charts have legends disabled or customized by default
};

function createLastPortfolioPieChart(details) {
    const chartDiv = document.getElementById('lastPortfolioPieChart');
    const stocks = details.stocks;
    const weights = details.weights;

    if (!stocks || !weights || stocks.length === 0) {
        chartDiv.innerText = 'No allocation data to display.';
        return;
    }

    const data = [{
        values: weights,
        labels: stocks,
        type: 'pie',
        hole: .4, // This turns the pie chart into a donut chart
        textinfo: "label+percent",
        textposition: "inside",
        automargin: true,
        insidetextorientation: 'radial'
    }];

    const layout = {
        ...PLOTLY_COMMON_LAYOUT,
        title: 'Latest Portfolio Allocation',
        margin: { t: 50, b: 20, l: 20, r: 20 }
    };

    Plotly.newPlot(chartDiv, data, layout, {responsive: true});
}

function renderOptimalPortfoliosStackedBarChart(summaryData) {
    const chartDiv = document.getElementById('optimalPortfoliosStackedBarChart');
    chartDiv.innerHTML = '';

    if (typeof Plotly === 'undefined' || !summaryData || summaryData.length === 0) {
        chartDiv.textContent = 'No portfolio data available for this chart (last 12 months).';
        return;
    }

    const runIds = summaryData.map(row => row.run_id);
    const allStocks = new Set();
    summaryData.forEach(row => {
        if (row.stocks) row.stocks.split(',').forEach(s => allStocks.add(s.trim()));
    });

    const sortedStocks = Array.from(allStocks).sort();
    const traces = sortedStocks.map(stock => {
        const y_values = Array(runIds.length).fill(0);

        summaryData.forEach((row, runIndex) => {
            const stocks = row.stocks ? row.stocks.split(',').map(s => s.trim()) : [];
            const weights = row.weights ? row.weights.split(',').map(w => parseFloat(w.trim())) : [];
            const stockIndex = stocks.indexOf(stock);
            if (stockIndex !== -1) {
                y_values[runIndex] = weights[stockIndex] * 100; // Convert to percentage
            }
        });
        return { x: runIds, y: y_values, name: stock, type: 'bar' };
    });

    const layout = {
        ...PLOTLY_COMMON_LAYOUT,
        title: 'Portfolio Composition per Run (Last 12 Months)',
        barmode: 'stack',
        margin: { t: 50, b: 150, l: 60, r: 30 }, // Increased bottom margin
        xaxis: {
            title: 'Run ID',
            type: 'category',
            tickangle: -45
        },
        yaxis: { title: 'Weight (%)', ticksuffix: '%' },
        showlegend: true,
        legend: { orientation: 'h', yanchor: 'bottom', y: -0.5, xanchor: 'center', x: 0.5 },
    };

    Plotly.newPlot(chartDiv, traces, layout, { responsive: true });
}
