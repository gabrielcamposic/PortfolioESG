/**
 * Fetches, parses, and displays data for the portfolio.html page.
 * This script handles the portfolio results, historical values, and summary details.
 */

// --- CONFIGURATION: Paths to the data files generated by Portfolio.py ---
const SUMMARY_CSV_PATH = 'data/portfolio_results_db.csv';
const HISTORY_CSV_PATH = 'data/portfolio_value_db.csv';
const LATEST_RUN_SUMMARY_JSON_PATH = 'data/latest_run_summary.json';

// --- MAIN EXECUTION ---
document.addEventListener('DOMContentLoaded', main);

async function main() {
    try {
        // FIX: Call the fetchAndParseCsv utility directly with the file paths.
        // This corrects the 404 error by letting the utility handle both fetching and parsing.
        const [allSummaryData, allPortfolioHistoryData, latestRunJson] = await Promise.all([
            fetchAndParseCsv(SUMMARY_CSV_PATH + '?t=' + new Date().getTime()),
            fetchAndParseCsv(HISTORY_CSV_PATH + '?t=' + new Date().getTime()),
            fetch(LATEST_RUN_SUMMARY_JSON_PATH + '?t=' + new Date().getTime()).then(res => {
                if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
                return res.json();
            })
        ]);

        const twelveMonthsAgo = new Date();
        twelveMonthsAgo.setFullYear(twelveMonthsAgo.getFullYear() - 1);
        twelveMonthsAgo.setHours(0, 0, 0, 0);

        // FIX: Filter by the correct 'timestamp' column.
        const filteredSummaryData = allSummaryData.filter(row => {
            const timestamp = new Date(row.timestamp);
            return timestamp && timestamp >= twelveMonthsAgo;
        }).sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp)); // Sort descending (newest first)

        // --- Render all components on the page ---
        displayLastPortfolioDetails(latestRunJson.best_portfolio_details, latestRunJson.last_updated_run_id);
        createLastPortfolioPieChart(latestRunJson.best_portfolio_details); // <-- ADD THIS LINE
        renderOptimalPortfoliosStackedBarChart(filteredSummaryData);
        renderMultiPortfolioHistoryChart(filteredSummaryData, allPortfolioHistoryData);
        renderSharpeFinalValueScatterChart(filteredSummaryData);
        populateResultsTable(filteredSummaryData);

    } catch (error) {
        console.error('Error in main function:', error);
        const errorMessage = `Error loading data: ${error.message}. Check console.`;
        document.getElementById('resultsTable').getElementsByTagName('tbody')[0].innerHTML = `<tr><td colspan="11" class="status-error-row">${errorMessage}</td></tr>`;
        document.getElementById('bestPortfolioTable').getElementsByTagName('tbody')[0].innerHTML = `<tr><td colspan="2" class="status-error-row">Error loading last portfolio details.</td></tr>`;
        // Clear loading text from charts
        document.getElementById('optimalPortfoliosStackedBarChart').textContent = 'Error loading chart data.';
        document.getElementById('multiPortfolioHistoryChart').textContent = 'Error loading chart data.';
        document.getElementById('sharpeFinalValueScatterChart').textContent = 'Error loading chart data.';
    }
}

// --- DOM UPDATE FUNCTIONS ---

function populateResultsTable(summaryData) {
    const tableBody = document.getElementById('resultsTable').getElementsByTagName('tbody')[0];
    tableBody.innerHTML = '';

    if (!summaryData || summaryData.length === 0) {
        tableBody.innerHTML = `<tr><td colspan="11" style="text-align:center;">No portfolio data found for the last 12 months.</td></tr>`;
        return;
    }

    // FIX: Use the correct property names from the CSV file.
    const rowsHtml = summaryData.map(row => `
        <tr>
            <td>${row.run_id || 'N/A'}</td>
            <td>${formatDate(row.timestamp)}</td>
            <td>${row.engine_version || 'N/A'}</td>
            <td>${row.min_stocks || 'N/A'}</td>
            <td>${row.max_stocks || 'N/A'}</td>
            <td>${row.stocks || 'N/A'}</td>
            <td>${row.weights || 'N/A'}</td>
            <td>${formatNumber(row.sharpe_ratio, 4)}</td>
            <td>${formatNumber(row.expected_return_annual_pct, 2)}%</td>
            <td>${formatNumber(row.expected_volatility_annual_pct, 2)}%</td>
            <td>${formatNumber(row.roi_percent, 2)}%</td>
        </tr>
    `).join('');
    tableBody.innerHTML = rowsHtml;
}

function displayLastPortfolioDetails(details, runId) {
    const tableBody = document.getElementById('bestPortfolioTable').getElementsByTagName('tbody')[0];
    tableBody.innerHTML = '';

    if (!details) {
        tableBody.innerHTML = `<tr><td colspan="2" style="text-align:center;">No portfolio found in the last run (ID: ${runId || 'N/A'}).</td></tr>`;
        return;
    }

    // FIX: Use the correct property names from the JSON file.
    const detailsMap = {
        "Run ID": runId || 'N/A',
        "Sharpe Ratio": formatNumber(details.sharpe_ratio, 4),
        "Optimal Stocks": details.stocks ? details.stocks.join(', ') : 'N/A',
        "Optimal Weights": details.weights ? details.weights.map(w => formatNumber(w, 4)).join(', ') : 'N/A',
        "Expected Annual Return": `${formatNumber(details.expected_return_annual_pct, 2)}%`,
        "Expected Annual Volatility": `${formatNumber(details.expected_volatility_annual_pct, 2)}%`,
        "Final Value": `$${formatNumber(details.final_value, 2)}`,
        "ROI": `${formatNumber(details.roi_percent, 2)}%`,
        "Initial Investment": `$${formatNumber(details.initial_investment, 2)}`
    };

    const rowsHtml = Object.entries(detailsMap).map(([metric, value]) => `
        <tr>
            <td><strong>${metric}</strong></td>
            <td>${value}</td>
        </tr>
    `).join('');
    tableBody.innerHTML = rowsHtml;
}


// --- CHARTING HELPERS & FUNCTIONS ---

/**
 * A shared configuration object for Plotly charts to ensure a consistent look and feel.
 */
const PLOTLY_COMMON_LAYOUT = {
    paper_bgcolor: 'rgba(0,0,0,0)',
    plot_bgcolor: 'rgba(0,0,0,0)',
    height: 450,
    showlegend: false // Most charts have legends disabled or customized by default
};

function createLastPortfolioPieChart(details) {
    const chartDiv = document.getElementById('lastPortfolioPieChart');
    const stocks = details.stocks;
    // The weights in the JSON are fractions (e.g., 0.25), which Plotly's 'pie' chart type correctly interprets as percentages.
    const weights = details.weights;

    if (!stocks || !weights || stocks.length === 0) {
        chartDiv.innerText = 'No allocation data to display.';
        return;
    }

    const data = [{
        values: weights,
        labels: stocks,
        type: 'pie',
        hole: .4, // This turns the pie chart into a donut chart
        textinfo: "label+percent",
        textposition: "inside",
        automargin: true,
        insidetextorientation: 'radial'
    }];

    const layout = {
        ...PLOTLY_COMMON_LAYOUT,
        title: 'Latest Portfolio Allocation',
        margin: { t: 50, b: 20, l: 20, r: 20 }
    };

    Plotly.newPlot(chartDiv, data, layout, {responsive: true});
}

function renderOptimalPortfoliosStackedBarChart(summaryData) {
    const chartDiv = document.getElementById('optimalPortfoliosStackedBarChart');
    chartDiv.innerHTML = '';

    if (typeof Plotly === 'undefined' || !summaryData || summaryData.length === 0) {
        chartDiv.textContent = 'No portfolio data available for this chart (last 12 months).';
        return;
    }

    // **THE FIX**: Use the unique run_id for the x-axis categories.
    const runIds = summaryData.map(row => row.run_id);
    const allStocks = new Set();
    summaryData.forEach(row => {
        if (row.stocks) row.stocks.split(',').forEach(s => allStocks.add(s.trim()));
    });

    const sortedStocks = Array.from(allStocks).sort();
    const traces = sortedStocks.map(stock => {
        // Initialize a y-array of zeros with the same length as our runIds
        const y_values = Array(runIds.length).fill(0);

        // Map each run's data to the correct index in the y_values array
        summaryData.forEach((row, runIndex) => {
            const stocks = row.stocks ? row.stocks.split(',').map(s => s.trim()) : [];
            const weights = row.weights ? row.weights.split(',').map(w => parseFloat(w.trim())) : [];
            const stockIndex = stocks.indexOf(stock);
            if (stockIndex !== -1) {
                y_values[runIndex] = weights[stockIndex] * 100; // Convert to percentage
            }
        });
        return { x: runIds, y: y_values, name: stock, type: 'bar' };
    });

    const layout = {
        ...PLOTLY_COMMON_LAYOUT,
        title: 'Portfolio Composition per Run (Last 12 Months)',
        barmode: 'stack',
        margin: { t: 50, b: 150, l: 60, r: 30 }, // Increased bottom margin
        xaxis: {
            title: 'Run ID',
            type: 'category', // Treat each run_id as a distinct column
            tickangle: -45    // Angle the labels to prevent overlap
        },
        yaxis: { title: 'Weight (%)', ticksuffix: '%' },
        showlegend: true,
        legend: { orientation: 'h', yanchor: 'bottom', y: -0.5, xanchor: 'center', x: 0.5 },
    };

    Plotly.newPlot(chartDiv, traces, layout, { responsive: true });
}

function renderMultiPortfolioHistoryChart(summaryData, historyData) {
    const chartDiv = document.getElementById('multiPortfolioHistoryChart');
    chartDiv.innerHTML = '';

    if (typeof Plotly === 'undefined' || !summaryData.length || !historyData.length) {
        chartDiv.textContent = 'No historical value data available.';
        return;
    }

    const runIds = new Set(summaryData.map(row => row.run_id));
    const relevantHistory = historyData.filter(row => row.run_id && runIds.has(row.run_id));
    const latestRunId = summaryData.length > 0 ? summaryData[summaryData.length - 1].run_id : null;

    const historyByRunId = relevantHistory.reduce((acc, row) => {
        const runId = row.run_id;
        if (!acc[runId]) acc[runId] = [];

        // FIX: Use correct property names 'Date' (capitalized) and 'value'.
        const date = new Date(row.Date);
        const value = parseFloat(row.value);

        if (date && !isNaN(value)) {
            acc[runId].push({ x: date, y: value });
        }
        return acc;
    }, {});

    const traces = Object.keys(historyByRunId).map(runId => {
        const dataPoints = historyByRunId[runId].sort((a, b) => a.x - b.x);
        const isLatest = runId === latestRunId;
        return {
            x: dataPoints.map(p => p.x),
            y: dataPoints.map(p => p.y),
            mode: 'lines',
            type: 'scatter',
            name: `Run ${runId}` + (isLatest ? ' (Latest)' : ''),
            line: { width: isLatest ? 3 : 1.5, color: isLatest ? '#ff6384' : undefined }
        };
    });

    const layout = {
        ...PLOTLY_COMMON_LAYOUT,
        title: 'Portfolio Historical Values (Last 12 Months)',
        margin: { t: 50, b: 80, l: 60, r: 30 },
        xaxis: { title: 'Date', type: 'date' },
        yaxis: { title: 'Portfolio Value ($)', tickprefix: '$' },
        showlegend: true,
    };

    Plotly.newPlot(chartDiv, traces, layout, { responsive: true });
}

function renderSharpeFinalValueScatterChart(summaryData) {
    const chartDiv = document.getElementById('sharpeFinalValueScatterChart');
    chartDiv.innerHTML = '';

    if (typeof Plotly === 'undefined' || !summaryData || summaryData.length === 0) {
        chartDiv.textContent = 'No data available for this chart.';
        return;
    }

    const latestRunId = summaryData.length > 0 ? summaryData[summaryData.length - 1].run_id : null;

    // FIX: Use correct property name 'stocks'.
    const traces = [{
        x: summaryData.map(row => parseFloat(row.sharpe_ratio)),
        y: summaryData.map(row => parseFloat(row.final_value)),
        mode: 'markers',
        type: 'scatter',
        text: summaryData.map(row => `Run: ${row.run_id}<br>Stocks: ${row.stocks}`),
        hoverinfo: 'text+x+y',
        marker: {
            size: summaryData.map(row => row.run_id === latestRunId ? 12 : 7),
            color: summaryData.map(row => row.run_id === latestRunId ? '#ff6384' : '#36a2eb'),
            opacity: 0.7
        }
    }];

    const layout = {
        ...PLOTLY_COMMON_LAYOUT,
        title: 'Portfolio Final Value vs. Sharpe Ratio (Last 12 Months)',
        margin: { t: 50, b: 80, l: 80, r: 30 },
        xaxis: { title: 'Sharpe Ratio' },
        yaxis: { title: 'Final Portfolio Value ($)', tickprefix: '$' },
    };

    Plotly.newPlot(chartDiv, traces, layout, { responsive: true });
}