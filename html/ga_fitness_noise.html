<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GA Fitness & Noise History</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        h1, h2 { color: #333; }
        nav { margin-bottom: 20px; }
        nav a { margin-right: 15px; text-decoration: none; color: #007bff; }
        nav a:hover { text-decoration: underline; }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            font-size: 0.9em;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th { background-color: #f2f2f2; }
        tr:nth-child(even) { background-color: #f9f9f9; }
        .chart-container {
            width: 80%;
            max-width: 900px;
            margin: 30px auto;
        }
        .table-container {
            overflow-x: auto; /* Allow horizontal scrolling for wide tables */
        }
    </style>
</head>
<body>
    <h1>Genetic Algorithm Fitness & Noise History</h1>
    <nav>
        <a href="progress.html">View Live Progress</a>
        <a href="results_history.html">View Run Results History</a>
        <a href="performance_history.html">View Performance History</a>
        <a href="download_performance_history.html">View Download Performance</a>
    </nav>

    <div class="chart-container">
        <h2>Best Sharpe Ratio by k and Sim Runs</h2>
        <canvas id="gaFitnessNoiseChart"></canvas>
    </div>

    <h2>Logged GA Fitness & Noise Data</h2>
    <div class="table-container">
        <table id="gaFitnessNoiseTable">
            <thead>
                <tr>
                    <th>Run Timestamp</th>
                    <th>Engine Version</th>
                    <th>k Size</th>
                    <th>Sim Runs (GA)</th>
                    <th>GA Pop Size</th>
                    <th>GA Num Gens</th>
                    <th>GA Mut Rate</th>
                    <th>GA Xover Rate</th>
                    <th>GA Elitism</th>
                    <th>GA Tournament</th>
                    <th>GA Conv Gens</th>
                    <th>GA Conv Tol</th>
                    <th>Best Sharpe Found (k)</th>
                </tr>
            </thead>
            <tbody>
                <!-- Data will be populated here by JavaScript -->
            </tbody>
        </table>
    </div>

    <script>
        const CSV_PATH = 'data/ga_fitness_noise_log.csv'; // Path to the new GA fitness/noise log

        function formatDate(dateString) {
            if (!dateString || dateString === "N/A") return "N/A";
            try {
                const dateObj = new Date(dateString.includes(' ') ? dateString : dateString + 'T00:00:00Z');
                if (isNaN(dateObj.getTime())) return dateString;

                const days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
                const months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

                const dayName = days[dateObj.getUTCDay()];
                const dayOfMonth = String(dateObj.getUTCDate()).padStart(2, '0');
                const monthName = months[dateObj.getUTCMonth()];
                const year = String(dateObj.getUTCFullYear()).slice(-2);
                const hours = String(dateObj.getUTCHours()).padStart(2, '0');
                const minutes = String(dateObj.getUTCMinutes()).padStart(2, '0');
                return `${dayName}, ${dayOfMonth}/${monthName}/${year} - ${hours}:${minutes}`;
            } catch (e) {
                return dateString;
            }
        }

        async function fetchAndDisplayGAFitnessNoise() {
            try {
                const response = await fetch(CSV_PATH + '?t=' + new Date().getTime()); // Cache buster
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status} while fetching ${CSV_PATH}`);
                }
                const csvText = await response.text();
                const rows = csvText.trim().split('\n');
                if (rows.length <= 1) { // Only header or empty
                    populateTable([], []);
                    renderChart([]); // Render empty chart
                    return;
                }

                const headersLine = rows[0];
                const headers = headersLine.split(',').map(h => h.trim());

                const data = rows.slice(1).map(rowString => {
                    let rowObject = {};
                    const regex = /(?:^|,)(\"(?:[^\"]+|\"\")*\"|[^,]*)/g;
                    let values = [];
                    let match;
                    while (match = regex.exec(rowString)) {
                        let value = match[1];
                        if (value.startsWith('"') && value.endsWith('"')) {
                            value = value.substring(1, value.length - 1).replace(/\"\"/g, '"');
                        }
                        values.push(value.trim());
                    }
                    headers.forEach((header, index) => {
                        rowObject[header] = values[index] !== undefined ? values[index] : 'N/A';
                    });
                    return rowObject;
                });

                populateTable(data, headers);
                renderChart(data);

            } catch (error) {
                console.error('Error fetching or parsing GA Fitness/Noise CSV:', error);
                const tableBody = document.getElementById('gaFitnessNoiseTable').getElementsByTagName('tbody')[0];
                const colspan = document.getElementById('gaFitnessNoiseTable').getElementsByTagName('thead')[0].rows[0].cells.length;
                tableBody.innerHTML = `<tr><td colspan="${colspan}" style="text-align:center; color:red;">Error loading data: ${error.message}. Ensure '${CSV_PATH}' is accessible.</td></tr>`;
                renderChart([]); // Render empty chart on error
            }
        }

        function populateTable(data, headers) {
            const tableBody = document.getElementById('gaFitnessNoiseTable').getElementsByTagName('tbody')[0];
            tableBody.innerHTML = ''; // Clear existing rows

            const expectedHeaders = ["run_start_timestamp", "engine_version", "k_size", "sim_runs_used_for_ga", "ga_pop_size", "ga_num_generations", "ga_mutation_rate", "ga_crossover_rate", "ga_elitism_count", "ga_tournament_size", "ga_convergence_generations", "ga_convergence_tolerance", "best_sharpe_found_for_k"];

            if (data.length === 0) {
                const colspan = headers.length > 0 ? headers.length : expectedHeaders.length; // Use actual headers length or expected
                tableBody.innerHTML = `<tr><td colspan="${colspan}" style="text-align:center;">No GA fitness or noise data found in CSV.</td></tr>`;
                return;
            }
            
            data.forEach(rowData => {
                const tr = tableBody.insertCell();
                headers.forEach(header => { // Iterate over each header for the current row
                    const td = tr.insertCell(); // Create a cell for each header
                    let cellValue = rowData[header.trim()] || 'N/A';

                    if (header.trim().toLowerCase() === 'run_start_timestamp') {
                        cellValue = formatDate(cellValue);
                    } else if (header.trim().toLowerCase() === 'best_sharpe_found_for_k' && cellValue !== 'N/A') {
                         cellValue = parseFloat(cellValue).toFixed(4);
                    } else if (header.trim().toLowerCase() === 'ga_mutation_rate' && cellValue !== 'N/A') {
                         cellValue = parseFloat(cellValue).toFixed(3); // Format rates
                    } else if (header.trim().toLowerCase() === 'ga_crossover_rate' && cellValue !== 'N/A') {
                         cellValue = parseFloat(cellValue).toFixed(3); // Format rates
                    } else if (header.trim().toLowerCase() === 'ga_convergence_tolerance' && cellValue !== 'N/A') {
                         cellValue = parseFloat(cellValue).toFixed(5); // Format tolerance
                    }
                    // Add more formatting for other numeric GA params if desired (e.g., toFixed(0) for counts)
                    td.textContent = cellValue;
                }); // This now correctly closes the headers.forEach loop
            });
        }

        function renderChart(data) {
            const ctx = document.getElementById('gaFitnessNoiseChart').getContext('2d');
            
            // Destroy existing chart if it exists
            if (window.gaFitnessNoiseChartInstance) {
                window.gaFitnessNoiseChartInstance.destroy();
            }

            if (data.length === 0) {
                 // Optionally display a message or just an empty chart area
                 return;
            }

            // Group data by k_size
            const dataByK = data.reduce((acc, row) => {
                const k = row.k_size;
                if (!acc[k]) {
                    acc[k] = [];
                }
                acc[k].push(row);
                return acc;
            }, {});

            const datasets = Object.keys(dataByK).sort((a, b) => parseInt(a) - parseInt(b)).map(k => {
                const kData = dataByK[k];
                return {
                    label: `k=${k}`,
                    data: kData.map(row => ({
                        x: parseInt(row.sim_runs_used_for_ga),
                        y: parseFloat(row.best_sharpe_found_for_k)
                    })).filter(point => !isNaN(point.x) && !isNaN(point.y)), // Filter out invalid points
                    borderColor: `hsl(${Math.random() * 360}, 70%, 50%)`, // Random color per k
                    backgroundColor: `hsl(${Math.random() * 360}, 70%, 50%, 0.5)`, // Semi-transparent points
                    showLine: false, // Don't connect points with lines
                    pointRadius: 5,
                    pointHoverRadius: 7,
                    type: 'scatter' // Use scatter plot type
                };
            });

            window.gaFitnessNoiseChartInstance = new Chart(ctx, {
                type: 'scatter', // Default type, though datasets specify 'scatter'
                data: {
                    datasets: datasets
                },
                options: {
                    scales: {
                        x: {
                            type: 'linear', // Use linear scale for sim runs
                            position: 'bottom',
                            title: {
                                display: true,
                                text: 'Sim Runs Used for GA Individual Evaluation'
                            },
                            ticks: {
                                callback: function(value, index, values) {
                                    // Only show integer ticks for sim runs
                                    if (Number.isInteger(value)) {
                                        return value;
                                    }
                                    return '';
                                }
                            }
                        },
                        y: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Best Sharpe Ratio Found for k'
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const label = context.dataset.label || '';
                                    if (label) {
                                        let tooltipText = label;
                                        const point = context.parsed;
                                        if (point) {
                                            tooltipText += `, Sim Runs: ${point.x}, Sharpe: ${point.y.toFixed(4)}`;
                                            // Find the original data row to add more details
                                            // Need to be careful matching points, especially if multiple runs have same k/sim_runs/sharpe
                                            // Matching on timestamp is most reliable, but not available in chart data structure directly.
                                            // For simplicity, find the *first* row that matches k, sim_runs, and formatted sharpe.
                                            // This might not be the *exact* row if multiple runs have identical results,
                                            // but it will provide the parameters from *one* such run.
                                            const originalRow = data.find(row => 
                                                parseInt(row.k_size) === parseInt(label.replace('k=', '')) &&
                                                parseInt(row.sim_runs_used_for_ga) === point.x &&
                                                // Compare formatted sharpe to handle floating point inaccuracies
                                                parseFloat(row.best_sharpe_found_for_k).toFixed(4) === point.y.toFixed(4) // Match on formatted sharpe
                                            );
                                            if (originalRow) {
                                                tooltipText += `, Run: ${formatDate(originalRow.run_start_timestamp)}`;
                                                tooltipText += `, Pop: ${originalRow.ga_pop_size}`;
                                                tooltipText += `, Gens: ${originalRow.ga_num_generations}`;
                                            }
                                            // Add other GA parameters to tooltip if found in originalRow
                                            if (originalRow && originalRow.ga_mutation_rate !== 'N/A') tooltipText += `, Mut Rate: ${parseFloat(originalRow.ga_mutation_rate).toFixed(3)}`;
                                            if (originalRow && originalRow.ga_crossover_rate !== 'N/A') tooltipText += `, Xover Rate: ${parseFloat(originalRow.ga_crossover_rate).toFixed(3)}`;
                                            if (originalRow && originalRow.ga_elitism_count !== 'N/A') tooltipText += `, Elitism: ${originalRow.ga_elitism_count}`;
                                            if (originalRow && originalRow.ga_tournament_size !== 'N/A') tooltipText += `, Tournament: ${originalRow.ga_tournament_size}`;
                                            if (originalRow && originalRow.ga_convergence_generations !== 'N/A') tooltipText += `, Conv Gens: ${originalRow.ga_convergence_generations}`;
                                        }
                                        return tooltipText;
                                    }
                                    return '';
                                }
                            }
                        }
                    },
                    responsive: true,
                    maintainAspectRatio: true
                }
            });
        }

        fetchAndDisplayGAFitnessNoise();
    </script>
</body>
</html>