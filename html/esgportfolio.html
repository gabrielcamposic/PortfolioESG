<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESG Portfolio</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/date-fns@^2/index.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@^2/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script> <!-- Added for scatter plot zoom -->
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.0/papaparse.min.js"></script>
    <link rel="stylesheet" href="css/styles.css"> <!-- Link to the common stylesheet -->
</head>
<body>
    <div id="navbar-placeholder"></div> <!-- Placeholder for the common navigation bar -->

    <div class="main-content">
        <h1>ESG Portfolio</h1>

    <!-- Section 1 (Formerly Section 2): Portfolio Historical Values -->
    <div class="stage-block">
        <h2>Portfolio Historical Values (Last 12 Months)</h2>
        <div class="chart-container">
            <canvas id="multiPortfolioHistoryChart"></canvas>
        </div>
    </div>
    
    <!-- Section 2 (Formerly Section 3): Sharpe Ratio & Final Value -->
    <div class="stage-block">
        <h2>Sharpe Ratio & Final Value (Last 12 Months)</h2>
        <div class="chart-container">
            <canvas id="sharpeFinalValueScatterChart"></canvas> <!-- Changed ID for the new scatter plot -->
        </div>
    </div>

    <!-- Section 3 (Formerly Section 1): Best Portfolio Details -->
    <div class="stage-block">
        <h2>Best Portfolio Details (Last 12 Months)</h2>
        <div id="bestPortfolioDetails" class="table-container"> <!-- Added table-container for consistency -->
            <table id="bestPortfolioTable"> <!-- Added ID for easier targeting -->
                <thead>
                    <tr>
                        <th>Metric</th>
                        <th>Value</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- JavaScript will populate this or show 'Loading...' -->
                    <tr><td colspan="2" style="text-align: center;">Loading best portfolio details...</td></tr>
                </tbody>
            </table>
        </div>
    </div>

    <!-- Section 4: Logged Portfolio Results -->
    <div class="stage-block">
        <h2>Logged Portfolio Results</h2>
        <table id="resultsTable">
            <thead>
                <tr>
                    <th>Run ID</th> 
                    <th>Timestamp</th>
                    <th>Engine Version</th>
                    <th>Min Stocks</th>
                    <th>Max Stocks</th>
                    <th>Data Start</th>
                    <th>Data End</th>
                    <th>Stock Pool</th>
                    <th>Optimal Stocks</th>
                    <th>Optimal Weights</th>
                    <th>Sharpe Ratio</th>
                    <th>Exp. Return (%)</th>
                    <th>Exp. Volatility (%)</th>
                    <th>Final Value</th>
                    <th>ROI (%)</th>
                    <th>Initial Investment</th>
                </tr>
            </thead>
            <tbody>
                <tr><td colspan="16" style="text-align: center;">Loading results...</td></tr>
            </tbody>
        </table>
    </div>
    </div> <!-- End of main-content -->

    <script>
        const SUMMARY_CSV_PATH = 'data/engine_results_log.csv';
        const HISTORY_CSV_PATH = 'data/portfolio_value_history.csv';

        let multiPortfolioHistoryChartInstance = null;
        // Removed sharpeRatioChartInstance, will use a new one for scatter plot

        // formatDate and getRandomColor are now in common_utils.js

        // Helper to parse CSV text using PapaParse
        function parseCsvWithPapaParse(csvText) {
            return new Promise((resolve, reject) => {
                Papa.parse(csvText, {
                    header: true,
                    skipEmptyLines: true,
                    dynamicTyping: false, // Keep as string initially, parse numbers explicitly later
                    complete: (results) => {
                        if (results.errors.length) {
                            reject(results.errors);
                        } else {
                            resolve(results.data);
                        }
                    },
                    error: (error) => reject(error)
                });
            });
        }

        // Parses a flexible date string into a Date object
        function parseFlexibleDate(dateString) {
            if (!dateString || dateString === "N/A") return null;
            // Attempt direct parsing (handles ISO formats and some others)
            let date = new Date(dateString);
            if (!isNaN(date.getTime())) {
                return date;
            }
            // Add more specific parsers if needed for formats like 'DD/MM/YYYY HH:MM:SS'
            console.warn(`Could not parse date: ${dateString}`);
            return null;
        }


        async function main() {
            try {
                const [summaryResponse, historyResponse] = await Promise.all([
                    fetch(SUMMARY_CSV_PATH + '?t=' + new Date().getTime()),
                    fetch(HISTORY_CSV_PATH + '?t=' + new Date().getTime())
                ]);

                if (!summaryResponse.ok) throw new Error(`HTTP error! status: ${summaryResponse.status} while fetching ${SUMMARY_CSV_PATH}`);
                if (!historyResponse.ok) throw new Error(`HTTP error! status: ${historyResponse.status} while fetching ${HISTORY_CSV_PATH}`);

                const summaryCsvText = await summaryResponse.text();
                const historyCsvText = await historyResponse.text();

                const allSummaryData = await parseCsvWithPapaParse(summaryCsvText);
                const allPortfolioHistoryData = await parseCsvWithPapaParse(historyCsvText);

                // Filter summary data for the last 12 months
                const twelveMonthsAgo = new Date();
                twelveMonthsAgo.setFullYear(twelveMonthsAgo.getFullYear() - 1);
                twelveMonthsAgo.setHours(0, 0, 0, 0);

                const filteredSummaryData = allSummaryData.filter(row => {
                    const timestamp = parseFlexibleDate(row.generation_timestamp);
                    return timestamp && timestamp >= twelveMonthsAgo;
                }).sort((a,b) => parseFlexibleDate(a.generation_timestamp) - parseFlexibleDate(b.generation_timestamp)); // Sort by date

                // Populate table with filtered summary data
                // Assuming headers are consistent, get them from the first row if data exists
                const summaryHeaders = filteredSummaryData.length > 0 ? Object.keys(filteredSummaryData[0]) : [
                    "run_id", "generation_timestamp", "engine_version", "min_target_stocks", "max_target_stocks",
                    "data_start_date", "data_end_date", "stock_pool_considered", "optimal_stocks",
                    "optimal_weights", "sharpe_ratio", "expected_annual_return_pct",
                    "expected_annual_volatility_pct", "final_value", "roi_pct", "initial_investment"
                ]; // Provide default headers if no data
                populateTable(filteredSummaryData, summaryHeaders);

                // Render the new scatter plot
                renderSharpeFinalValueScatterChart(filteredSummaryData);

                // Identify and display best portfolio details
                const bestPortfolio = findBestPortfolio(filteredSummaryData);
                displayBestPortfolioDetails(bestPortfolio);

                // Render new multi-portfolio history chart
                renderMultiPortfolioHistoryChart(filteredSummaryData, allPortfolioHistoryData);

            } catch (error) {
                let errorMessage = "An unknown error occurred.";
                if (Array.isArray(error) && error.length > 0 && error[0] && typeof error[0].message !== 'undefined') {
                    // Likely a PapaParse error array
                    const papaError = error[0];
                    errorMessage = `CSV Parsing Error: ${papaError.message} (Code: ${papaError.code || 'N/A'}, Type: ${papaError.type || 'N/A'}, Row: ${typeof papaError.row !== 'undefined' ? papaError.row + 2 : 'N/A'})`; // row is 0-indexed, +2 for header and 1-based
                    console.error('Detailed PapaParse Error:', papaError);
                } else if (error.message) {
                    // Standard JavaScript error
                    errorMessage = error.message;
                } else {
                    // Fallback for other types of errors
                    errorMessage = String(error);
                }
                console.error('Error in main function (fetching/parsing CSV):', error); // Log the original error object too
                const tableBody = document.getElementById('resultsTable').getElementsByTagName('tbody')[0];
                tableBody.innerHTML = `<tr><td colspan="16" style="text-align:center; color:red;">Error loading data: ${errorMessage}. Check console for details.</td></tr>`;
                document.getElementById('bestPortfolioDetails').innerHTML = `<p style="color:red;">Error loading best portfolio details: ${errorMessage}. Check console for details.</p>`;
            }
        }

        function findBestPortfolio(summaryData) {
            if (!summaryData || summaryData.length === 0) return null;
            return summaryData.reduce((best, current) => {
                const currentSharpe = parseFloat(current.sharpe_ratio);
                const bestSharpe = best ? parseFloat(best.sharpe_ratio) : -Infinity;
                return (!isNaN(currentSharpe) && currentSharpe > bestSharpe) ? current : best;
            }, null);
        }

        function populateTable(summaryData, headers) {
            const tableBody = document.getElementById('resultsTable').getElementsByTagName('tbody')[0];
            tableBody.innerHTML = ''; // Clear existing rows

            if (summaryData.length === 0) {
                tableBody.innerHTML = `<tr><td colspan="${headers.length}" style="text-align:center;">No data found in CSV.</td></tr>`;
                return;
            }

            summaryData.forEach(rowData => {
                const tr = tableBody.insertRow();
                headers.forEach(header => {
                    const td = tr.insertCell();
                    let cellValue = rowData[header.trim()] || 'N/A';
                    if (header.trim().toLowerCase() === 'generation_timestamp' || header.trim().toLowerCase() === 'data_start_date' || header.trim().toLowerCase() === 'data_end_date') {
                        cellValue = formatDate(cellValue);
                    }
                    td.textContent = cellValue;
                });
            });
        }

        function displayBestPortfolioDetails(portfolio) {
            const tableBody = document.getElementById('bestPortfolioTable')?.getElementsByTagName('tbody')[0];
            const detailsContainer = document.getElementById('bestPortfolioDetails');

            if (!tableBody) {
                if(detailsContainer) detailsContainer.innerHTML = '<p style="color:red;">Error: Best portfolio table structure not found.</p>';
                console.error("Element with ID 'bestPortfolioTable' or its tbody not found.");
                return;
            }
            tableBody.innerHTML = ''; // Clear previous content

            if (!portfolio) {
                const tr = tableBody.insertRow();
                const td = tr.insertCell();
                td.colSpan = 2;
                td.style.textAlign = "center";
                td.textContent = 'No portfolio data available for the last 12 months to determine the best.';
                return;
            }

            const detailsMap = {
                "Run ID": portfolio.run_id || 'N/A',
                "Generated": formatDate(portfolio.generation_timestamp),
                "Sharpe Ratio": parseFloat(portfolio.sharpe_ratio).toFixed(4) || 'N/A',
                "Optimal Stocks": portfolio.optimal_stocks || 'N/A',
                "Optimal Weights": portfolio.optimal_weights || 'N/A',
                "Expected Annual Return": `${parseFloat(portfolio.expected_annual_return_pct).toFixed(2) || 'N/A'}%`,
                "Expected Annual Volatility": `${parseFloat(portfolio.expected_annual_volatility_pct).toFixed(2) || 'N/A'}%`,
                "Final Value": `$${parseFloat(portfolio.final_value).toFixed(2) || 'N/A'}`,
                "ROI": `${parseFloat(portfolio.roi_pct).toFixed(2) || 'N/A'}%`,
                "Initial Investment": `$${parseFloat(portfolio.initial_investment).toFixed(2) || 'N/A'}`
            };

            for (const metric in detailsMap) {
                const tr = tableBody.insertRow();
                const metricTd = tr.insertCell();
                metricTd.textContent = metric;
                const valueTd = tr.insertCell();
                valueTd.textContent = detailsMap[metric];
            }
        }

        async function renderSharpeFinalValueScatterChart(summaryData) { // summaryData is already filtered and available
            const chartCanvasId = 'sharpeFinalValueScatterChart';

            if (window.sharpeFinalValueScatterInstance) {
                window.sharpeFinalValueScatterInstance.destroy();
            }
            const ctx = document.getElementById(chartCanvasId).getContext('2d');

            if (!summaryData || summaryData.length === 0) {
                console.warn('No summary data provided for scatter plot.');
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                ctx.font = "16px Arial";
                ctx.fillStyle = "grey";
                ctx.textAlign = "center";
                ctx.fillText("No data available for this chart (last 12 months).", ctx.canvas.width / 2, ctx.canvas.height / 2);
                return;
            }

            const scatterDataPoints = summaryData
                .filter(row => row.run_id && row.sharpe_ratio != null && row.final_value != null)
                .map(row => ({
                    x: parseFloat(row.sharpe_ratio),
                    y: parseFloat(row.final_value),
                    run_id: row.run_id,
                    timestamp: row.generation_timestamp, // Keep original string for tooltip
                    optimal_stocks: row.optimal_stocks
                }));

            if (scatterDataPoints.length === 0) {
                console.warn('No valid data points after filtering for scatter plot.');
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                ctx.font = "16px Arial";
                ctx.fillStyle = "grey";
                ctx.textAlign = "center";
                ctx.fillText("No valid data points to display (last 12 months).", ctx.canvas.width / 2, ctx.canvas.height / 2);
                return;
            }
            
            window.sharpeFinalValueScatterInstance = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Portfolio Run (Last 12 Months)',
                        data: scatterDataPoints,
                        backgroundColor: 'rgba(54, 162, 235, 0.6)',
                        borderColor: 'rgba(54, 162, 235, 1)',
                        pointRadius: 6,
                        pointHoverRadius: 9
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true, // Or false if you want more control via CSS
                    scales: {
                        x: {
                            type: 'linear',
                            position: 'bottom',
                            title: {
                                display: true,
                                text: 'Sharpe Ratio',
                                font: { size: 14, weight: 'bold' }
                            }
                        },
                        y: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Final Portfolio Value ($)',
                                font: { size: 14, weight: 'bold' }
                            },
                            ticks: {
                                callback: function(value) {
                                    return '$' + value.toLocaleString(undefined, {minimumFractionDigits: 0, maximumFractionDigits: 0});
                                }
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Portfolio Final Value vs. Sharpe Ratio (Last 12 Months)',
                            font: { size: 18, weight: 'bold' }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const point = context.raw;
                                    let label = [];
                                    label.push(`Run ID: ${point.run_id}`);
                                    label.push(`Sharpe Ratio: ${point.x.toFixed(4)}`);
                                    label.push(`Final Value: $${point.y.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`);
                                    if (point.timestamp) {
                                        label.push(`Timestamp: ${formatDate(point.timestamp)}`);
                                    }
                                    if (point.optimal_stocks) {
                                        label.push(`Stocks: ${point.optimal_stocks.length > 40 ? point.optimal_stocks.substring(0,37) + '...' : point.optimal_stocks }`)
                                    }
                                    return label;
                                }
                            }
                        },
                        zoom: { // Enable zoom and pan
                            pan: { enabled: true, mode: 'xy' },
                            zoom: {
                                wheel: { enabled: true },
                                pinch: { enabled: true },
                                mode: 'xy',
                            }
                        }
                    }
                }
            });
        }

        function renderMultiPortfolioHistoryChart(filteredSummaryData, allPortfolioHistoryData) {
            if (multiPortfolioHistoryChartInstance) {
                multiPortfolioHistoryChartInstance.destroy();
            }
            if (!filteredSummaryData.length || !allPortfolioHistoryData.length) {
                document.getElementById('multiPortfolioHistoryChart').style.display = 'none'; // Hide if no data
                return;
            }
            document.getElementById('multiPortfolioHistoryChart').style.display = 'block';

            const recentRunIds = new Set(filteredSummaryData.map(row => row.run_id));
            const relevantHistory = allPortfolioHistoryData.filter(histRow => recentRunIds.has(histRow.RunID));

            if (relevantHistory.length === 0) return;

            const historyByRunId = relevantHistory.reduce((acc, row) => {
                if (!acc[row.RunID]) acc[row.RunID] = [];
                const date = parseFlexibleDate(row.Date);
                const value = parseFloat(row.PortfolioValue);
                if (date && !isNaN(value)) {
                    acc[row.RunID].push({ x: date, y: value });
                }
                return acc;
            }, {});

            const datasets = [];
            Object.keys(historyByRunId).forEach(runId => {
                const dataPoints = historyByRunId[runId].sort((a,b) => a.x - b.x); // Sort by date
                if (dataPoints.length > 0) {
                    datasets.push({
                        label: `Run ${runId}`,
                        data: dataPoints,
                        borderColor: getRandomColor(),
                        tension: 0.1,
                        fill: false
                    });
                }
            });

            if (datasets.length === 0) return;

            const ctx = document.getElementById('multiPortfolioHistoryChart').getContext('2d');
            multiPortfolioHistoryChartInstance = new Chart(ctx, {
                type: 'line',
                data: { datasets: datasets },
                options: {
                    scales: {
                        x: {
                            type: 'time',
                            time: { unit: 'day', tooltipFormat: 'MMM dd, yyyy', displayFormats: { day: 'MMM dd, yy'}},
                            title: { display: true, text: 'Date' }
                        },
                        y: {
                            title: { display: true, text: 'Portfolio Value ($)' },
                            beginAtZero: false
                        }
                    },
                    responsive: true,
                    maintainAspectRatio: true
                }
            });
        }

        main();
        // Removed the old navbar update script; common_nav.js handles it.
    </script>
    <script src="js/common_utils.js"></script> <!-- Load common utility functions -->
    <script src="js/common_nav.js"></script> <!-- Load the common navigation script -->
</body>
</html>