<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portfolio Simulation</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        .progress-bar {
            width: 100%;
            background-color: #f3f3f3;
            border: 1px solid #ccc;
            border-radius: 5px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-bar-inner {
            height: 20px;
            background-color: #4caf50;
            width: 0%;
        }
        .section {
            margin-bottom: 40px;
        }
        .columns {
            display: flex;
            justify-content: space-between;
            gap: 20px;
        }
        .column {
            flex: 1;
        }
        img {
            max-width: 100%;
            height: auto;
            border: 1px solid #ccc;
            border-radius: 5px;
            margin-top: 20px;
        }
        .engine-timing-info {
            display: flex;
            justify-content: space-between;
            gap: 20px; /* Adjust gap as needed */
            margin-bottom: 15px; /* Space below this block */
        }
        .status-columns { /* New class for the status section */
            display: flex;
            justify-content: space-between;
            gap: 20px;
        }
        .engine-timing-info > div { /* Target direct div children of .engine-timing-info */
            flex: 1; /* Make them share space equally, like .column */
        }
    </style>
</head>
<body>
    <h1>Simulation Progress</h1>
    <nav>
        <a href="results_history.html">View Run History</a>
        <a href="performance_history.html">View Performance History</a>
        <a href="ga_fitness_noise.html">View GA Fitness/Noise</a>
    </nav>


    <!-- Stock Database Update Section -->
    <div class="section">
        <h2>Stock database update</h2>
        <div class="status-columns"> <!-- Reusing status-columns for flex layout -->
            <div class="column"> <!-- Left Column -->
                <p>Execution Started At: <span id="execution-start-time">N/A</span></p>
                <p>Execution Ended At: <span id="execution-end-time">N/A</span></p>                
                <p>Overall Status: <span id="download-overall-status">Pending</span></p>
                <div class="progress-bar">
                    <div class="progress-bar-inner" id="ticker-progress-bar"></div>
                </div>
            </div>
            <div class="column"> <!-- Right Column -->
                <p>Date Range: <span id="ticker-date-range">N/A</span></p>
                <p>Current Ticker: <span id="ticker-current">N/A</span></p>
                <p>Completed Tickers: <span id="ticker-completed">0</span> / <span id="ticker-total">0</span></p>
                <p>Rows Downloaded: <span id="ticker-rows">0</span></p>
            </div>
        </div>
    </div>

    <!-- Portfolio Simulation Progress Section -->
    <div class="section">

        <h2>Portfolio Optimization Progress</h2>
        <div class="engine-timing-info">
            <div>
                <p><strong>Engine Script Started:</strong> <span id="engine-script-start-time">N/A</span></p>
                <p><strong>Initial Estimated Completion:</strong> <span id="engine-initial-est-completion">N/A</span></p>
            </div>
            <div>
                <p><strong>Engine Script Ended:</strong> <span id="engine-script-end-time">N/A</span></p>
                <p><strong>Total Engine Duration:</strong> <span id="engine-script-total-duration">N/A</span></p>
            </div>
        </div>
        <div class="status-columns"> <!-- New parent container for two columns -->
            <div class="column"> <!-- First column -->
                <p><strong>Overall Status:</strong> <span id="engine-overall-status">Pending</span></p>
                <div>
                    <strong>Overall Engine Progress:</strong>
                    <div class="progress-bar"><div class="progress-bar-inner" id="engine-overall-progress-bar"></div></div>
                </div>
            </div>
            <div class="column"> <!-- Second column -->
                <p><strong>Current Phase:</strong> <span id="engine-current-phase">N/A</span></p>
                <div>
                    <strong>Current Phase Progress:</strong>
                    <div class="progress-bar"><div class="progress-bar-inner" id="engine-current-phase-progress-bar"></div></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Best ESG Portfolio Chart Section -->
    <div class="section">
        <h2>Best Overall Portfolio</h2>
        <div id="best-esg-portfolio-info">
            <p>Stocks: <span id="best-esg-stocks">N/A</span></p>
            <p>Weights: <span id="best-esg-weights">N/A</span></p>
            <p>Sharpe Ratio: <span id="best-esg-sharpe">N/A</span></p>
            <p>Initial Investment: <span id="best-esg-initial">N/A</span></p>
            <p>Final Value: <span id="best-esg-final">N/A</span></p>
            <p>ROI: <span id="best-esg-roi">N/A</span></p>
            <p>Expected Annual Return: <span id="best-esg-exp-ret">N/A</span></p>
            <p>Expected Annual Volatility: <span id="best-esg-exp-vol">N/A</span></p>
        </div>
    </div>

    <script>
        let fetchInterval;
    
        function formatDate(dateString) {
            if (!dateString || dateString === "N/A") return "N/A";
            try {
                // Handle cases where only date is provided or if it's already a full datetime string
                const dateObj = new Date(dateString.includes(' ') ? dateString : dateString + 'T00:00:00Z'); // Assume UTC if only date
                if (isNaN(dateObj.getTime())) return dateString; // Return original if invalid

                const days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
                const months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

                const dayName = days[dateObj.getUTCDay()];
                const dayOfMonth = String(dateObj.getUTCDate()).padStart(2, '0');
                const monthName = months[dateObj.getUTCMonth()];
                const year = String(dateObj.getUTCFullYear()).slice(-2);
                const hours = String(dateObj.getUTCHours()).padStart(2, '0');
                const minutes = String(dateObj.getUTCMinutes()).padStart(2, '0');

                return `${dayName}, ${dayOfMonth}/${monthName}/${year} - ${hours}:${minutes}`;
            } catch (e) {
                console.warn("Could not format date:", dateString, e);
                return dateString; // Return original if error
            }
        }

        function formatDuration(durationString) {
            if (!durationString || durationString === "N/A") return "N/A";
            let totalSeconds = 0;
            let days = 0;

            const dayMatch = durationString.match(/(\d+)\s*day[s]?,\s*/);
            if (dayMatch) {
                days = parseInt(dayMatch[1]);
                durationString = durationString.substring(dayMatch[0].length);
            }

            if (durationString.includes(':')) {
                const parts = durationString.split(':');
                if (parts.length === 3) {
                    const secondsAndMs = parts[2].split('.');
                    totalSeconds = parseInt(parts[0]) * 3600 + parseInt(parts[1]) * 60 + parseInt(secondsAndMs[0]);
                } else { return durationString; }
            } else if (!isNaN(parseFloat(durationString))) {
                totalSeconds = parseFloat(durationString);
            } else { return durationString; }
            if (isNaN(totalSeconds)) return durationString;
            totalSeconds += days * 86400;
            const finalDays = Math.floor(totalSeconds / 86400);
            let remSec = totalSeconds % 86400;
            const finalHours = Math.floor(remSec / 3600); remSec %= 3600;
            const finalMinutes = Math.floor(remSec / 60); const finalSeconds = Math.floor(remSec % 60);
            return `${finalDays > 0 ? `${finalDays} day${finalDays > 1 ? 's' : ''} and ` : ''}${String(finalHours).padStart(2, '0')}:${String(finalMinutes).padStart(2, '0')}:${String(finalSeconds).padStart(2, '0')}`;
        }

        function formatTickerDateRange(rangeString) {
            if (!rangeString || rangeString === "N/A" || !rangeString.includes(" to ")) {
                 // If it's a single date or N/A, format it fully.
                return formatDate(rangeString);
            }
            const parts = rangeString.split(" to ");
            if (parts.length === 2) {
                // For ranges, typically we only show the date part.
                const startDate = formatDate(parts[0]).split(' - ')[0];
                const endDate = formatDate(parts[1]).split(' - ')[0];
                return `${startDate} to ${endDate}`;
            }
            return rangeString; // Fallback
        }

        async function fetchProgress() {
            try {
                const response = await fetch('progress.json?t=' + new Date().getTime());
                const data = await response.json();
    
                // Helper function for safe text update
                function setText(id, value, defaultValue = 'N/A') {
                    const element = document.getElementById(id);
                    if (element) {
                        element.textContent = (value !== undefined && value !== null) ? String(value) : defaultValue;
                    }
                }
    
                // Helper function for safe progress bar update
                function setProgress(id, value) {
                    const element = document.getElementById(id);
                    if (element) {
                        element.style.width = `${Math.max(0, Math.min(100, parseFloat(value) || 0))}%`;
                    }
                }

                // --- Stock Database Update Section (for download.py) ---
                if (data.ticker_download) {
                    const t = data.ticker_download;
                    setText('ticker-completed', t.completed_tickers, '0');
                    setText('ticker-total', t.total_tickers, '0');                    
                    setProgress('ticker-progress-bar', t.progress);
                    setText('ticker-current', t.current_ticker); // No date format
                    setText('ticker-date-range', formatTickerDateRange(t.date_range));
                    setText('ticker-rows', t.rows, '0');
                }
                // These are likely for download.py script timing
                setText('execution-start-time', formatDate(data.download_execution_start)); 
                setText('execution-end-time', formatDate(data.download_execution_end));
                setText('download-overall-status', data.download_overall_status, 'Pending'); // Update download status
    
                // --- Engine.py - Portfolio Optimization Progress Section ---
                setText('engine-script-start-time', formatDate(data.engine_script_start_time));
                setText('engine-initial-est-completion', formatDate(data.estimated_completion_time)); 

                // Construct the detailed "Current Phase" string
                let basePhaseString = data.current_engine_phase || "N/A";
                let detailsToAppend = [];
                const currentPhase = data.current_engine_phase ? data.current_engine_phase.toLowerCase() : "";

                if (currentPhase.includes("brute-force") && data.overall_progress) {
                    const bf = data.overall_progress;
                    if (bf.completed_actual_simulations_bf !== undefined && bf.total_expected_actual_simulations_bf !== undefined) {
                        detailsToAppend.push(`Sims: ${bf.completed_actual_simulations_bf}/${bf.total_expected_actual_simulations_bf}`);
                    }
                    if (bf.percentage_bf !== undefined) {
                        detailsToAppend.push(`Progress: ${parseFloat(bf.percentage_bf).toFixed(0)}%`);
                    }
                } else if (currentPhase.includes("genetic algorithm") && data.ga_progress) {
                    const ga = data.ga_progress;
                    if (typeof ga.current_generation === 'number' && typeof ga.total_generations_ga === 'number') {
                        let genStr = `Gen: ${ga.current_generation}/${ga.total_generations_ga}`;
                        if (ga.status && ga.status.toLowerCase().includes("running") && typeof ga.current_individual_ga === 'number' && typeof ga.total_individuals_ga === 'number' && ga.total_individuals_ga > 0) {
                            genStr += ` (Ind: ${ga.current_individual_ga}/${ga.total_individuals_ga})`;
                        }
                        detailsToAppend.push(genStr);
                    }
                    if (ga.best_sharpe_this_k && ga.best_sharpe_this_k !== "N/A") {
                        detailsToAppend.push(`Best Sharpe (k): ${parseFloat(ga.best_sharpe_this_k).toFixed(4)}`);
                    }
                } else if (currentPhase.includes("refinement") && data.refinement_progress) {
                    const refine = data.refinement_progress;
                    if (refine.current_combo_refined !== undefined && refine.total_combos_to_refine !== undefined) {
                        detailsToAppend.push(`Combo: ${refine.current_combo_refined}/${refine.total_combos_to_refine}`);
                    }
                }

                let finalPhaseDisplayString = basePhaseString;
                if (detailsToAppend.length > 0) {
                    if (basePhaseString.endsWith(")")) { // Assumes phases like "Brute-Force (k=X)"
                        finalPhaseDisplayString = `${basePhaseString.slice(0, -1)}, ${detailsToAppend.join(', ')})`;
                    } else { // For phases like "Refinement Phase"
                        finalPhaseDisplayString = `${basePhaseString} (${detailsToAppend.join(', ')})`;
                    }
                }
                setText('engine-current-phase', finalPhaseDisplayString);

                // Engine.py Overall Status Logic
                let engineStatus = 'Pending'; // Default status
                const engineStartTime = data.engine_script_start_time;
                const engineEndTime = data.engine_script_end_time;
                const downloadStartTime = data.download_execution_start;
                const downloadEndTime = data.download_execution_end;

                if (engineStartTime && engineStartTime !== "N/A") { // Engine has a valid start time
                    if (!engineEndTime || engineEndTime === "N/A") { // Engine has not ended
                        engineStatus = 'Running...';
                    } else { // Engine has a valid end time (and it's not "N/A")
                        engineStatus = 'Completed';
                    }
                } else if (downloadStartTime && downloadStartTime !== "N/A" && (!downloadEndTime || downloadEndTime === "N/A")) { 
                    // Engine hasn't started, but Download.py is running
                    engineStatus = 'Waiting for Download.py';
                }
                setText('engine-overall-status', engineStatus);

                // Overall Engine Progress Bar (qualitative based on phase)
                let overallEngineProgressValue = 0; // currentPhase already defined above
                if (data.engine_script_end_time && data.engine_script_end_time !== "N/A") {
                    overallEngineProgressValue = 100;
                } else if (currentPhase.includes("initializing") || currentPhase.includes("data loading") || currentPhase.includes("wrangling")) {
                    overallEngineProgressValue = 5;
                } else if (currentPhase.includes("brute-force")) {
                    const bfProgress = data.overall_progress ? (parseFloat(data.overall_progress.percentage_bf) || 0) : 0;
                    overallEngineProgressValue = 10 + (bfProgress * 0.40); // BF contributes 40% (range 10-50)
                } else if (currentPhase.includes("genetic algorithm")) {
                    const gaProgress = data.ga_progress ? (parseFloat(data.ga_progress.percentage_ga) || 0) : 0;
                    overallEngineProgressValue = 50 + (gaProgress * 0.40); // GA contributes 40% (range 50-90)
                } else if (currentPhase.includes("refinement")) {
                    const refinementProgress = data.refinement_progress ? (parseFloat(data.refinement_progress.percentage_refinement) || 0) : 0;
                    overallEngineProgressValue = 90 + (refinementProgress * 0.08); // Refinement is 8% (range 90-98)
                } else if (engineStatus === "Running...") { // General running state if phase not specific
                    overallEngineProgressValue = Math.max(overallEngineProgressValue, 5); // At least some progress if running
                }
                setProgress('engine-overall-progress-bar', overallEngineProgressValue);

                // Current Phase Progress Bar
                let currentPhaseProgressValue = 0;
                if (currentPhase.includes("brute-force") && data.overall_progress) {
                    currentPhaseProgressValue = parseFloat(data.overall_progress.percentage_bf) || 0;
                } else if (currentPhase.includes("genetic algorithm") && data.ga_progress) {
                    currentPhaseProgressValue = parseFloat(data.ga_progress.percentage_ga) || 0;
                } else if (currentPhase.includes("refinement") && data.refinement_progress) {
                    currentPhaseProgressValue = parseFloat(data.refinement_progress.percentage_refinement) || 0;
                } else if (currentPhase.includes("initializing") || currentPhase.includes("data loading") || currentPhase.includes("wrangling")) {
                    currentPhaseProgressValue = 50; // Indicate activity for these quick phases
                }
                setProgress('engine-current-phase-progress-bar', currentPhaseProgressValue);

                if (data.overall_progress) { // This key from Engine.py is for Brute-Force
                    const bf = data.overall_progress;
                    // The data from bf (overall_progress) is used above in constructing finalPhaseDisplayString
                    // No separate setText calls needed here for the removed bf-details-section elements
                }

                setText('engine-script-end-time', formatDate(data.engine_script_end_time));
                setText('engine-script-total-duration', formatDuration(data.engine_script_total_duration));

                // Check for overall completion to stop fetching (can be refined)
                if (data.engine_script_end_time && data.execution_end) { // If both main scripts seem done
                    if (fetchInterval) {
                        clearInterval(fetchInterval);
                        console.log('Progress complete. Stopping updates.');
                    }
                }
    
                // --- Best Overall Portfolio Section (from Engine.py) ---
                if (data.best_portfolio_details) {
                    const best = data.best_portfolio_details;
                    setText('best-esg-stocks', best.stocks ? best.stocks.join(', ') : 'N/A');
                    setText('best-esg-weights', best.weights ? best.weights.map(w => parseFloat(w).toFixed(4)).join(', ') : 'N/A');
                    setText('best-esg-sharpe', best.sharpe_ratio !== undefined ? parseFloat(best.sharpe_ratio).toFixed(4) : 'N/A');
                    setText('best-esg-initial', best.initial_investment !== undefined ? `$${parseFloat(best.initial_investment).toFixed(2)}` : 'N/A'); // Assumes Engine.py adds this
                    setText('best-esg-final', best.final_value !== undefined ? `$${parseFloat(best.final_value).toFixed(2)}` : 'N/A');
                    setText('best-esg-roi', best.roi_percent !== undefined ? `${parseFloat(best.roi_percent).toFixed(2)}%` : 'N/A');
                    setText('best-esg-exp-ret', best.expected_return_annual_pct !== undefined ? `${parseFloat(best.expected_return_annual_pct).toFixed(2)}%` : 'N/A');
                    setText('best-esg-exp-vol', best.expected_volatility_annual_pct !== undefined ? `${parseFloat(best.expected_volatility_annual_pct).toFixed(2)}%` : 'N/A');
                    
                }
    
            } catch (error) {
                console.error('Error fetching progress:', error);
            }
        }
    
        fetchInterval = setInterval(fetchProgress, 10000);
        fetchProgress();
    </script>

</body>
</html>