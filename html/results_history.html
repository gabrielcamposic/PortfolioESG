<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Engine Run History</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        h1, h2 { color: #333; }
        nav { margin-bottom: 20px; }
        nav a { margin-right: 15px; text-decoration: none; color: #007bff; }
        nav a:hover { text-decoration: underline; }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            font-size: 0.9em;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th { background-color: #f2f2f2; }
        tr:nth-child(even) { background-color: #f9f9f9; }
        .chart-container {
            width: 80%;
            max-width: 900px;
            margin: 30px auto;
        }
    </style>
</head>
<body>
    <h1>Engine Run History</h1>
    <nav>
        <a href="progress.html">View Live Progress</a>
    </nav>

    <div class="chart-container">
        <h2>Sharpe Ratio Over Time</h2>
        <canvas id="sharpeRatioChart"></canvas>
    </div>

    <h2>Logged Portfolio Results</h2>
    <table id="resultsTable">
        <thead>
            <tr>
                <th>Timestamp</th>
                <th>Engine Version</th>
                <th>Min Stocks</th>
                <th>Max Stocks</th>
                <th>Data Start</th>
                <th>Data End</th>
                <th>Stock Pool</th>
                <th>Optimal Stocks</th>
                <th>Optimal Weights</th>
                <th>Sharpe Ratio</th>
                <th>Exp. Return (%)</th>
                <th>Exp. Volatility (%)</th>
                <th>Final Value</th>
                <th>ROI (%)</th>
                <th>Initial Investment</th>
            </tr>
        </thead>
        <tbody>
            <!-- Data will be populated here by JavaScript -->
        </tbody>
    </table>

    <script>
        const CSV_PATH = 'data/engine_results_log.csv'; // Adjust if your CSV is elsewhere

        function formatDate(dateString) {
            if (!dateString || dateString === "N/A") return "N/A";
            try {
                // Handle cases where only date is provided or if it's already a full datetime string
                const dateObj = new Date(dateString.includes(' ') ? dateString : dateString + 'T00:00:00Z'); // Assume UTC
                if (isNaN(dateObj.getTime())) return dateString; // Return original if invalid

                const days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
                const months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

                const dayName = days[dateObj.getUTCDay()];
                const dayOfMonth = String(dateObj.getUTCDate()).padStart(2, '0');
                const monthName = months[dateObj.getUTCMonth()];
                const year = String(dateObj.getUTCFullYear()).slice(-2);
                const hours = String(dateObj.getUTCHours()).padStart(2, '0');
                const minutes = String(dateObj.getUTCMinutes()).padStart(2, '0');

                return `${dayName}, ${dayOfMonth}/${monthName}/${year} - ${hours}:${minutes}`;
            } catch (e) {
                return dateString; // Return original if error
            }
        }

        async function fetchAndDisplayResults() {
            try {
                const response = await fetch(CSV_PATH + '?t=' + new Date().getTime()); // Cache buster
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status} while fetching ${CSV_PATH}`);
                }
                const csvText = await response.text();
                const rows = csvText.trim().split('\n');
                const headersLine = rows[0];
                // Headers are usually simple, so a basic split is often okay.
                // If headers could also be complex/quoted, this would need the same regex logic.
                const headers = headersLine.split(',').map(h => h.trim());

                const data = rows.slice(1).map(rowString => {
                    let rowObject = {};
                    const regex = /(?:^|,)(\"(?:[^\"]+|\"\")*\"|[^,]*)/g; // CSV field parsing regex
                    let values = [];
                    let match;

                    // Use regex to extract values, respecting quotes
                    while (match = regex.exec(rowString)) {
                        let value = match[1]; // The captured group contains the field
                        // Remove surrounding quotes if present and unescape double quotes "" to "
                        if (value.startsWith('"') && value.endsWith('"')) {
                            value = value.substring(1, value.length - 1).replace(/\"\"/g, '"');
                        }
                        values.push(value.trim());
                    }

                    headers.forEach((header, index) => {
                        rowObject[header] = values[index] !== undefined ? values[index] : 'N/A';
                    });
                    return rowObject;
                });

                populateTable(data, headers);
                renderChart(data);

            } catch (error) {
                console.error('Error fetching or parsing CSV:', error);
                const tableBody = document.getElementById('resultsTable').getElementsByTagName('tbody')[0];
                tableBody.innerHTML = `<tr><td colspan="${(headers && headers.length > 0) ? headers.length : 15}" style="text-align:center; color:red;">Error loading data: ${error.message}. Ensure '${CSV_PATH}' is accessible.</td></tr>`;
            }
        }

        function populateTable(data, headers) {
            const tableBody = document.getElementById('resultsTable').getElementsByTagName('tbody')[0];
            tableBody.innerHTML = ''; // Clear existing rows

            if (data.length === 0) {
                tableBody.innerHTML = `<tr><td colspan="${headers.length}" style="text-align:center;">No data found in CSV.</td></tr>`;
                return;
            }

            data.forEach(rowData => {
                const tr = tableBody.insertRow();
                headers.forEach(header => {
                    const td = tr.insertCell();
                    let cellValue = rowData[header.trim()] || 'N/A';
                    if (header.trim().toLowerCase() === 'generation_timestamp' || header.trim().toLowerCase() === 'data_start_date' || header.trim().toLowerCase() === 'data_end_date') {
                        cellValue = formatDate(cellValue);
                    }
                    td.textContent = cellValue;
                });
            });
        }

        function renderChart(data) {
            if (data.length === 0) return;

            const timestamps = data.map(row => formatDate(row.generation_timestamp));
            const sharpeRatios = data.map(row => parseFloat(row.sharpe_ratio));
            const finalValues = data.map(row => parseFloat(row.final_value)); // Extract final values

            const ctx = document.getElementById('sharpeRatioChart').getContext('2d');
            new Chart(ctx, {
                type: 'line',
                data: {
                    labels: timestamps,
                    datasets: [{
                        label: 'Sharpe Ratio',
                        data: sharpeRatios,
                        borderColor: 'rgb(75, 192, 192)',
                        tension: 0.1,
                        fill: false,
                        yAxisID: 'ySharpe' // Assign to the first y-axis
                    }, {
                        label: 'Final Portfolio Value', // New dataset
                        data: finalValues,
                        borderColor: 'rgb(255, 99, 132)', // Different color
                        tension: 0.1,
                        fill: false,
                        yAxisID: 'yFinalValue' // Assign to the second y-axis
                    }]
                },
                options: {
                    scales: {
                        x: { title: { display: true, text: 'Generation Timestamp' } },
                        ySharpe: { // Configuration for the primary y-axis (Sharpe Ratio)
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: { display: true, text: 'Sharpe Ratio' }
                        },
                        yFinalValue: { // Configuration for the secondary y-axis (Final Value)
                            type: 'linear',
                            display: true,
                            position: 'right',
                            title: { display: true, text: 'Final Value ($)' },
                            grid: { drawOnChartArea: false } // Only draw grid for the primary axis
                        }
                    },
                    responsive: true,
                    maintainAspectRatio: true
                }
            });
        }

        fetchAndDisplayResults();
    </script>
</body>
</html>