<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Engine Run History</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.0/papaparse.min.js"></script> <!-- Added PapaParse for easier CSV parsing -->
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding-left: 240px; /* Match progress.html */
            padding-top: 20px;
            padding-right: 20px;
            padding-bottom: 20px;
            background-color: #f8f9fa;
            color: #343a40;
            font-size: 1rem;
            line-height: 1; /* Match progress.html (Note: this is very tight) */
        }
        h1 {
            color: #2c3e50;
            text-align: left;
            margin-bottom: 30px;
            margin-top: 0;
            font-size: 2.4em;
            font-weight: 600;
        }
        nav {
            position: fixed;
            left: 0;
            top: 0;
            width: 220px; /* Match progress.html */
            height: 100%;
            background-color: #343a40;
            padding-top: 20px;
            overflow-y: auto;
            color: #f8f9fa;
        }
        .nav-section-title, nav h2 {
            color: #f8f9fa;
            font-size: 0.9em;
            text-align: left;
            padding-left: 20px;
            margin-top: 0;
            margin-bottom: 10px;
            font-weight: 600;
        }
        nav h2 { margin-top: 10px; } /* Specific margin for "Navigation" title */
        nav a {
            display: block;
            padding: 10px 20px; /* Match progress.html */
            text-decoration: none;
            color: #dee2e6;
            font-size: 0.9em; /* Standardized font size */
            transition: background-color 0.3s ease, color 0.3s ease;
            /* text-align: left; removed to match progress.html (block elements default to left) */
        }
        
        nav a:hover { /* Match progress.html hover effect */
            background-color: #495057;
            color: #ffffff;
        }

        .stage-block {
            background-color: #fff;
            border: 1px solid #e0e0e0;
            padding: 20px;
            margin-bottom: 25px; /* Space between blocks */
            border-radius: 6px; /* Slightly less rounded */
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }
        .stage-block:hover {
             border-color: #bdc3c7;
             box-shadow: 0 3px 6px rgba(0,0,0,0.07);
        }
        .stage-block h2 {
            margin-top: 0;
            color: #34495e;
            border-bottom: 1px solid #dee2e6; /* Lighter border */
            padding-bottom: 10px;
            margin-bottom: 15px; /* Space below heading */
            font-size: 1.75em; /* Stage title size */
            font-weight: 600;
        }
        /* Ensure paragraphs within stage-blocks have consistent styling */
        .stage-block p { margin-bottom: 8px; font-size: 0.95em; color: #495057; }
        .stage-block strong { color: #343a40; font-weight: bold; }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            font-size: 0.9em;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th { background-color: #f2f2f2; }
        tr:nth-child(even) { background-color: #f9f9f9; }
        .chart-container {
            width: 80%;
            max-width: 900px;
            margin: 30px auto;
        }
        /* Styles for pipeline status details within the nav bar (will show N/A) */
        #nav-pipeline-status-details {
            padding: 0px 0px 10px 0px;
            margin-bottom: 0;
        }
        #nav-pipeline-status-details p {
            color: #adb5bd;
            font-size: 0.9em;
            margin-bottom: 4px;
            line-height: 1.3;
            padding-left: 20px;
            text-align: left;
        }
        #nav-pipeline-status-details p strong {
            color: #dee2e6;
            font-weight: 500;
        }
        #nav-pipeline-status-details .status-text {
            font-weight: 500;
        }
        .nav-divider {
            margin: 0px 20px 10px 20px;
            border-color: #495057;
            margin-bottom: 10px;
        }
        .nav-footer {
            position: absolute;
            bottom: 10px;
            left: 0;
            width: 100%;
            text-align: center;
            padding-bottom: 10px;
        }
        .nav-footer p {
            font-size: 0.75em;
            color: #adb5bd;
            margin: 0;
            padding: 5px 0;
        }
    </style>
</head>
<body>
    <nav>
        <div id="nav-pipeline-status-details">
            <h4 class="nav-section-title">Pipeline Status</h4>
            <p><strong>Status:</strong> <span id="pipeline-status-message" class="status-text">N/A</span></p>
            <p><strong>Started:</strong> <span id="pipeline-start-time">N/A</span></p>
            <p><strong>Ended:</strong> <span id="pipeline-end-time-nav">N/A</span></p>
            <p><strong>Stage:</strong> <span id="pipeline-current-stage">N/A</span></p>
        </div>
        <hr class="nav-divider">
        <h2>Navigation</h2>
        <a href="progress.html">Pipeline Status</a>
        <a href="results_history.html">Portfolio History</a>
        <a href="performance_history.html">Engine Performance</a>
        <a href="download_performance_history.html">Script Performance</a>
        <a href="ga_fitness_noise.html">GA Fitness/Noise</a>
        <div class="nav-footer">
            <p>HTML v1.0.0</p> <!-- Version for results_history.html -->
        </div>
    </nav>
    <div class="main-content">
        <h1>Engine Run History</h1>

    <!-- Section 1: Best Portfolio Details -->
    <div class="stage-block">
        <h2>Best Portfolio Details (Last 12 Months)</h2>
        <div id="bestPortfolioDetails">
            <p>Loading best portfolio details...</p>
        </div>
    </div>

    <!-- Section 2: Portfolio Historical Values -->
    <div class="stage-block">
        <h2>Portfolio Historical Values (Last 12 Months)</h2>
        <div class="chart-container">
            <canvas id="multiPortfolioHistoryChart"></canvas>
        </div>
    </div>

    <!-- Section 3: Sharpe Ratio & Final Value -->
    <div class="stage-block">
        <h2>Sharpe Ratio & Final Value (Last 12 Months)</h2>
        <div class="chart-container">
            <canvas id="sharpeRatioChart"></canvas>
        </div>
    </div>

    <!-- Section 4: Logged Portfolio Results -->
    <div class="stage-block">
        <h2>Logged Portfolio Results</h2>
        <table id="resultsTable">
            <thead>
                <tr>
                    <th>Run ID</th> 
                    <th>Timestamp</th>
                    <th>Engine Version</th>
                    <th>Min Stocks</th>
                    <th>Max Stocks</th>
                    <th>Data Start</th>
                    <th>Data End</th>
                    <th>Stock Pool</th>
                    <th>Optimal Stocks</th>
                    <th>Optimal Weights</th>
                    <th>Sharpe Ratio</th>
                    <th>Exp. Return (%)</th>
                    <th>Exp. Volatility (%)</th>
                    <th>Final Value</th>
                    <th>ROI (%)</th>
                    <th>Initial Investment</th>
                </tr>
            </thead>
            <tbody>
                <tr><td colspan="16" style="text-align: center;">Loading results...</td></tr>
            </tbody>
        </table>
    </div>
    </div> <!-- End of main-content -->

    <script>
        const SUMMARY_CSV_PATH = 'data/engine_results_log.csv';
        const HISTORY_CSV_PATH = 'data/portfolio_value_history.csv';

        let sharpeRatioChartInstance = null;
        let multiPortfolioHistoryChartInstance = null;

        function formatDate(dateString) {
            if (!dateString || dateString === "N/A") return "N/A";
            try {
                // Handle cases where only date is provided or if it's already a full datetime string
                const dateObj = new Date(dateString.includes(' ') ? dateString.replace(' ', 'T') : dateString + 'T00:00:00Z'); // Assume UTC if only date
                if (isNaN(dateObj.getTime())) return dateString; // Return original if invalid

                const days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
                const months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
                const useLocalGetters = dateString.includes(' ') && !dateString.endsWith('Z') && !(typeof dateString === 'string' && dateString.match(/[+-]\d{2}:\d{2}$/));

                const dayName = useLocalGetters ? days[dateObj.getDay()] : days[dateObj.getUTCDay()];
                const dayOfMonth = String(useLocalGetters ? dateObj.getDate() : dateObj.getUTCDate()).padStart(2, '0');
                const monthName = useLocalGetters ? months[dateObj.getMonth()] : months[dateObj.getUTCMonth()];
                const year = useLocalGetters ? dateObj.getFullYear() : dateObj.getUTCFullYear(); // Display full year
                const hours = String(useLocalGetters ? dateObj.getHours() : dateObj.getUTCHours()).padStart(2, '0');
                const minutes = String(useLocalGetters ? dateObj.getMinutes() : dateObj.getUTCMinutes()).padStart(2, '0');

                return `${dayName}, ${dayOfMonth}/${monthName}/${year} - ${hours}:${minutes}`;
            } catch (e) {
                return dateString; // Return original if error
            }
        }

        // Helper to parse CSV text using PapaParse
        function parseCsvWithPapaParse(csvText) {
            return new Promise((resolve, reject) => {
                Papa.parse(csvText, {
                    header: true,
                    skipEmptyLines: true,
                    dynamicTyping: false, // Keep as string initially, parse numbers explicitly later
                    complete: (results) => {
                        if (results.errors.length) {
                            reject(results.errors);
                        } else {
                            resolve(results.data);
                        }
                    },
                    error: (error) => reject(error)
                });
            });
        }

        // Parses a flexible date string into a Date object
        function parseFlexibleDate(dateString) {
            if (!dateString || dateString === "N/A") return null;
            // Attempt direct parsing (handles ISO formats and some others)
            let date = new Date(dateString);
            if (!isNaN(date.getTime())) {
                return date;
            }
            // Add more specific parsers if needed for formats like 'DD/MM/YYYY HH:MM:SS'
            console.warn(`Could not parse date: ${dateString}`);
            return null;
        }


        async function main() {
            try {
                const [summaryResponse, historyResponse] = await Promise.all([
                    fetch(SUMMARY_CSV_PATH + '?t=' + new Date().getTime()),
                    fetch(HISTORY_CSV_PATH + '?t=' + new Date().getTime())
                ]);

                if (!summaryResponse.ok) throw new Error(`HTTP error! status: ${summaryResponse.status} while fetching ${SUMMARY_CSV_PATH}`);
                if (!historyResponse.ok) throw new Error(`HTTP error! status: ${historyResponse.status} while fetching ${HISTORY_CSV_PATH}`);

                const summaryCsvText = await summaryResponse.text();
                const historyCsvText = await historyResponse.text();

                const allSummaryData = await parseCsvWithPapaParse(summaryCsvText);
                const allPortfolioHistoryData = await parseCsvWithPapaParse(historyCsvText);

                // Filter summary data for the last 12 months
                const twelveMonthsAgo = new Date();
                twelveMonthsAgo.setFullYear(twelveMonthsAgo.getFullYear() - 1);
                twelveMonthsAgo.setHours(0, 0, 0, 0);

                const filteredSummaryData = allSummaryData.filter(row => {
                    const timestamp = parseFlexibleDate(row.generation_timestamp);
                    return timestamp && timestamp >= twelveMonthsAgo;
                }).sort((a,b) => parseFlexibleDate(a.generation_timestamp) - parseFlexibleDate(b.generation_timestamp)); // Sort by date

                // Populate table with filtered summary data
                // Assuming headers are consistent, get them from the first row if data exists
                const summaryHeaders = filteredSummaryData.length > 0 ? Object.keys(filteredSummaryData[0]) : [
                    "run_id", "generation_timestamp", "engine_version", "min_target_stocks", "max_target_stocks",
                    "data_start_date", "data_end_date", "stock_pool_considered", "optimal_stocks",
                    "optimal_weights", "sharpe_ratio", "expected_annual_return_pct",
                    "expected_annual_volatility_pct", "final_value", "roi_pct", "initial_investment"
                ]; // Provide default headers if no data
                populateTable(filteredSummaryData, summaryHeaders);

                // Render existing Sharpe/Final Value chart with filtered summary data
                renderSharpeAndFinalValueChart(filteredSummaryData);

                // Identify and display best portfolio details
                const bestPortfolio = findBestPortfolio(filteredSummaryData);
                displayBestPortfolioDetails(bestPortfolio);

                // Render new multi-portfolio history chart
                renderMultiPortfolioHistoryChart(filteredSummaryData, allPortfolioHistoryData);

            } catch (error) {
                let errorMessage = "An unknown error occurred.";
                if (Array.isArray(error) && error.length > 0 && error[0] && typeof error[0].message !== 'undefined') {
                    // Likely a PapaParse error array
                    const papaError = error[0];
                    errorMessage = `CSV Parsing Error: ${papaError.message} (Code: ${papaError.code || 'N/A'}, Type: ${papaError.type || 'N/A'}, Row: ${typeof papaError.row !== 'undefined' ? papaError.row + 2 : 'N/A'})`; // row is 0-indexed, +2 for header and 1-based
                    console.error('Detailed PapaParse Error:', papaError);
                } else if (error.message) {
                    // Standard JavaScript error
                    errorMessage = error.message;
                } else {
                    // Fallback for other types of errors
                    errorMessage = String(error);
                }
                console.error('Error in main function (fetching/parsing CSV):', error); // Log the original error object too
                const tableBody = document.getElementById('resultsTable').getElementsByTagName('tbody')[0];
                tableBody.innerHTML = `<tr><td colspan="16" style="text-align:center; color:red;">Error loading data: ${errorMessage}. Check console for details.</td></tr>`;
                document.getElementById('bestPortfolioDetails').innerHTML = `<p style="color:red;">Error loading best portfolio details: ${errorMessage}. Check console for details.</p>`;
            }
        }

        function findBestPortfolio(summaryData) {
            if (!summaryData || summaryData.length === 0) return null;
            return summaryData.reduce((best, current) => {
                const currentSharpe = parseFloat(current.sharpe_ratio);
                const bestSharpe = best ? parseFloat(best.sharpe_ratio) : -Infinity;
                return (!isNaN(currentSharpe) && currentSharpe > bestSharpe) ? current : best;
            }, null);
        }

        function populateTable(summaryData, headers) {
            const tableBody = document.getElementById('resultsTable').getElementsByTagName('tbody')[0];
            tableBody.innerHTML = ''; // Clear existing rows

            if (summaryData.length === 0) {
                tableBody.innerHTML = `<tr><td colspan="${headers.length}" style="text-align:center;">No data found in CSV.</td></tr>`;
                return;
            }

            summaryData.forEach(rowData => {
                const tr = tableBody.insertRow();
                headers.forEach(header => {
                    const td = tr.insertCell();
                    let cellValue = rowData[header.trim()] || 'N/A';
                    if (header.trim().toLowerCase() === 'generation_timestamp' || header.trim().toLowerCase() === 'data_start_date' || header.trim().toLowerCase() === 'data_end_date') {
                        cellValue = formatDate(cellValue);
                    }
                    td.textContent = cellValue;
                });
            });
        }

        function displayBestPortfolioDetails(portfolio) {
            const detailsDiv = document.getElementById('bestPortfolioDetails');
            if (!portfolio) {
                detailsDiv.innerHTML = '<p>No portfolio data available for the last 12 months to determine the best.</p>';
                return;
            }
            detailsDiv.innerHTML = `
                <p><strong>Run ID:</strong> ${portfolio.run_id || 'N/A'}</p>
                <p><strong>Generated:</strong> ${formatDate(portfolio.generation_timestamp)}</p>
                <p><strong>Sharpe Ratio:</strong> ${parseFloat(portfolio.sharpe_ratio).toFixed(4) || 'N/A'}</p>
                <p><strong>Optimal Stocks:</strong> ${portfolio.optimal_stocks || 'N/A'}</p>
                <p><strong>Optimal Weights:</strong> ${portfolio.optimal_weights || 'N/A'}</p>
                <p><strong>Expected Annual Return:</strong> ${parseFloat(portfolio.expected_annual_return_pct).toFixed(2) || 'N/A'}%</p>
                <p><strong>Expected Annual Volatility:</strong> ${parseFloat(portfolio.expected_annual_volatility_pct).toFixed(2) || 'N/A'}%</p>
                <p><strong>Final Value:</strong> $${parseFloat(portfolio.final_value).toFixed(2) || 'N/A'}</p>
                <p><strong>ROI:</strong> ${parseFloat(portfolio.roi_pct).toFixed(2) || 'N/A'}%</p>
                <p><strong>Initial Investment:</strong> $${parseFloat(portfolio.initial_investment).toFixed(2) || 'N/A'}</p>
            `;
        }

        function renderSharpeAndFinalValueChart(summaryData) {
            if (sharpeRatioChartInstance) {
                sharpeRatioChartInstance.destroy();
            }
            if (summaryData.length === 0) return;

            const timestamps = summaryData.map(row => parseFlexibleDate(row.generation_timestamp)); // Use actual Date objects
            const sharpeRatios = summaryData.map(row => parseFloat(row.sharpe_ratio));
            const finalValues = summaryData.map(row => parseFloat(row.final_value));
            
            const ctx = document.getElementById('sharpeRatioChart').getContext('2d');
            sharpeRatioChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: timestamps,
                    datasets: [{
                        label: 'Sharpe Ratio',
                        data: sharpeRatios,
                        borderColor: 'rgb(75, 192, 192)',
                        tension: 0.1,
                        fill: false,
                        yAxisID: 'ySharpe' // Assign to the first y-axis
                    }, {
                        label: 'Final Portfolio Value', // New dataset
                        data: finalValues,
                        borderColor: 'rgb(255, 99, 132)', // Different color
                        tension: 0.1,
                        fill: false,
                        yAxisID: 'yFinalValue' // Assign to the second y-axis
                    }]
                },
                options: {
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'day',
                                tooltipFormat: 'MMM dd, yyyy HH:mm',
                                displayFormats: { day: 'MMM dd, yy' }
                            },
                            title: { display: true, text: 'Generation Timestamp' }
                        },
                        ySharpe: { // Configuration for the primary y-axis (Sharpe Ratio)
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: { display: true, text: 'Sharpe Ratio' }
                        },
                        yFinalValue: { // Configuration for the secondary y-axis (Final Value)
                            type: 'linear',
                            display: true,
                            position: 'right',
                            title: { display: true, text: 'Final Value ($)' },
                            grid: { drawOnChartArea: false } // Only draw grid for the primary axis
                        }
                    },
                    responsive: true,
                    maintainAspectRatio: true
                }
            });
        }

        function renderMultiPortfolioHistoryChart(filteredSummaryData, allPortfolioHistoryData) {
            if (multiPortfolioHistoryChartInstance) {
                multiPortfolioHistoryChartInstance.destroy();
            }
            if (!filteredSummaryData.length || !allPortfolioHistoryData.length) {
                document.getElementById('multiPortfolioHistoryChart').style.display = 'none'; // Hide if no data
                return;
            }
            document.getElementById('multiPortfolioHistoryChart').style.display = 'block';

            const recentRunIds = new Set(filteredSummaryData.map(row => row.run_id));
            const relevantHistory = allPortfolioHistoryData.filter(histRow => recentRunIds.has(histRow.RunID));

            if (relevantHistory.length === 0) return;

            const historyByRunId = relevantHistory.reduce((acc, row) => {
                if (!acc[row.RunID]) acc[row.RunID] = [];
                const date = parseFlexibleDate(row.Date);
                const value = parseFloat(row.PortfolioValue);
                if (date && !isNaN(value)) {
                    acc[row.RunID].push({ x: date, y: value });
                }
                return acc;
            }, {});

            const datasets = [];
            Object.keys(historyByRunId).forEach(runId => {
                const dataPoints = historyByRunId[runId].sort((a,b) => a.x - b.x); // Sort by date
                if (dataPoints.length > 0) {
                    datasets.push({
                        label: `Run ${runId}`,
                        data: dataPoints,
                        borderColor: getRandomColor(),
                        tension: 0.1,
                        fill: false
                    });
                }
            });

            if (datasets.length === 0) return;

            const ctx = document.getElementById('multiPortfolioHistoryChart').getContext('2d');
            multiPortfolioHistoryChartInstance = new Chart(ctx, {
                type: 'line',
                data: { datasets: datasets },
                options: {
                    scales: {
                        x: {
                            type: 'time',
                            time: { unit: 'day', tooltipFormat: 'MMM dd, yyyy', displayFormats: { day: 'MMM dd, yy'}},
                            title: { display: true, text: 'Date' }
                        },
                        y: {
                            title: { display: true, text: 'Portfolio Value ($)' },
                            beginAtZero: false
                        }
                    },
                    responsive: true,
                    maintainAspectRatio: true
                }
            });
        }

        function getRandomColor() {
            return `rgb(${Math.floor(Math.random() * 200)}, ${Math.floor(Math.random() * 200)}, ${Math.floor(Math.random() * 200)})`;
        }

        main();
    </script>
</body>
</html>